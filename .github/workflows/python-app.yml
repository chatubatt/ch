import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
from io import BytesIO
import warnings
warnings.filterwarnings('ignore')

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Agendador Inteligente de F√©rias",
    page_icon="üìÖ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Lista de feriados nacionais
FERIADOS = [
    '2025-01-01', '2025-03-03', '2025-03-04', '2025-04-18', '2025-04-21',
    '2025-05-01', '2025-06-19', '2025-09-07', '2025-10-12',
    '2025-11-02', '2025-11-15', '2025-11-20', '2025-12-25'
]
FERIADOS = [datetime.strptime(d, '%Y-%m-%d').date() for d in FERIADOS]

def eh_dia_util(d):
    """Verifica se uma data √© dia √∫til (n√£o √© fim de semana nem feriado)"""
    return d.weekday() < 5 and d not in FERIADOS

def proximo_dia_util(d):
    """Encontra o pr√≥ximo dia √∫til ap√≥s uma data"""
    while not eh_dia_util(d):
        d += timedelta(days=1)
    return d

def gerar_data_fim(inicio, dias):
    """Calcula a data fim das f√©rias baseada no in√≠cio e quantidade de dias"""
    return inicio + timedelta(days=dias-1)

def processar_centro_custo(centro_custo_str):
    """Processa string de centro de custo para extrair informa√ß√µes relevantes"""
    if pd.isna(centro_custo_str) or str(centro_custo_str).lower() in ['nan', 'none', '']:
        return '000', 'Outros', 'Outros'
    
    partes = str(centro_custo_str).split(' - ')
    
    # Extrair c√≥digo num√©rico (primeira parte)
    codigo = partes[0] if len(partes) > 0 else '000'
    
    # Extrair descri√ß√£o principal (terceira parte, se existir)
    if len(partes) >= 3:
        descricao = partes[2]
        # Simplificar removendo prefixos regionais
        descricao_limpa = descricao.replace('Sp ', '').replace('Cg ', '').replace('Rh ', '').strip()
        categoria = descricao_limpa.title()
    else:
        categoria = 'Outros'
    
    return codigo, partes[2] if len(partes) >= 3 else 'Outros', categoria

def criar_mapeamento_celula_subcelula(df):
    """Cria mapeamento entre c√©lulas centrais e suas subc√©lulas"""
    mapeamento = {}
    for _, row in df.iterrows():
        celula = row['CelulaCentral']
        subcelula = row['Unidade']
        if pd.notna(celula) and pd.notna(subcelula):
            if celula not in mapeamento:
                mapeamento[celula] = set()
            mapeamento[celula].add(subcelula)
    return mapeamento

def classificar_hierarquia_cargo(cargo):
    """Classifica o cargo em n√≠veis hier√°rquicos para prioriza√ß√£o"""
    if pd.isna(cargo) or str(cargo).lower() in ['nan', 'none', '']:
        return 3  # N√≠vel padr√£o para cargos n√£o especificados
    
    cargo_lower = str(cargo).lower()
    
    # N√≠vel 1: Alta gest√£o (prioridade m√°xima na distribui√ß√£o)
    if any(palavra in cargo_lower for palavra in ['diretor', 'gerente', 'superintendente', 'presidente']):
        return 1
    
    # N√≠vel 2: Gest√£o intermedi√°ria
    elif any(palavra in cargo_lower for palavra in ['supervisor', 'coordenador', 'chefe', 'l√≠der']):
        return 2
    
    # N√≠vel 3: Operacional
    else:
        return 3

def calcular_limite_por_cargo(df_unidade, cargo, percentual_base):
    """Calcula limite espec√≠fico de colaboradores por cargo que podem sair simultaneamente"""
    total_cargo = len(df_unidade[df_unidade['Cargo'] == cargo])
    nivel_hierarquico = classificar_hierarquia_cargo(cargo)
    
    if nivel_hierarquico == 1:  # Alta gest√£o
        return 1  # M√°ximo 1 diretor/gerente por vez
    elif nivel_hierarquico == 2:  # Gest√£o intermedi√°ria
        return max(1, int(total_cargo * 0.5))  # M√°ximo 50% dos supervisores
    else:  # Operacional
        return max(1, int(total_cargo * percentual_base))  # Percentual padr√£o

def validar_estrutura_arquivo(df):
    """Valida se o arquivo possui a estrutura correta"""
    erros = []
    
    if len(df.columns) < 14:
        erros.append("‚ùå Arquivo deve ter pelo menos 14 colunas (A at√© N)")
    
    # Validar coluna C (Nome)
    if df.iloc[:, 2].isna().all():
        erros.append("‚ùå Coluna C (Nome dos colaboradores) est√° completamente vazia")
    
    # Validar coluna F (Centro de Custo)
    if df.iloc[:, 5].isna().all():
        erros.append("‚ùå Coluna F (Centro de Custo) est√° completamente vazia")
    
    # Validar coluna G (Unidade)
    if df.iloc[:, 6].isna().all():
        erros.append("‚ùå Coluna G (Unidade/Subc√©lula) est√° completamente vazia")
    
    # Validar coluna M (Data Limite)
    if df.iloc[:, 12].isna().all():
        erros.append("‚ùå Coluna M (Data Limite) est√° completamente vazia")
    
    # Validar coluna N (Cargo) - opcional mas recomendada
    if len(df.columns) > 13 and df.iloc[:, 13].isna().all():
        erros.append("‚ö†Ô∏è Coluna N (Cargo) est√° vazia - funcionalidade de distribui√ß√£o por cargo ser√° limitada")
    
    return erros

def processar_distribuicao_completa(df, celulas_sel, unidades_sel, dias, percentual, data_inicial):
    """
    Fun√ß√£o aprimorada para garantir distribui√ß√£o de 100% da planilha
    com m√∫ltiplas tentativas e ajustes autom√°ticos
    """
    df_resultado_final = df[
        df["CelulaCentral"].isin(celulas_sel) &
        df["Unidade"].isin(unidades_sel)
    ].copy()
    
    # Inicializar colunas de resultado
    df_resultado_final["DataInicioFerias"] = pd.NaT
    df_resultado_final["DataFimFerias"] = pd.NaT
    df_resultado_final["Lote"] = None
    
    colaboradores_ignorados = []
    colaboradores_processados = 0
    tentativas = 0
    max_tentativas = 3
    percentual_atual = percentual
    
    while tentativas < max_tentativas:
        pendentes = df_resultado_final[df_resultado_final['DataInicioFerias'].isna()]
        
        if pendentes.empty:
            break  # Todos foram processados
            
        st.info(f"‚öôÔ∏è Tentativa {tentativas + 1} de {max_tentativas} - Processando {len(pendentes)} colaboradores pendentes...")
        
        # Processar pendentes com par√¢metros atuais
        df_temp, ignorados_temp, stats_temp = processar_distribuicao_com_cargo(
            pendentes, celulas_sel, unidades_sel, dias, percentual_atual, 
            data_inicial + timedelta(days=tentativas * 30)  # Avan√ßar data inicial a cada tentativa
        )
        
        # Atualizar resultado final
        mask = df_temp['DataInicioFerias'].notna()
        df_resultado_final.loc[df_temp[mask].index, 'DataInicioFerias'] = df_temp.loc[mask, 'DataInicioFerias']
        df_resultado_final.loc[df_temp[mask].index, 'DataFimFerias'] = df_temp.loc[mask, 'DataFimFerias']
        df_resultado_final.loc[df_temp[mask].index, 'Lote'] = df_temp.loc[mask, 'Lote']
        
        colaboradores_processados += (df_temp['DataInicioFerias'].notna()).sum()
        colaboradores_ignorados.extend(ignorados_temp)
        
        # Aumentar percentual para pr√≥xima tentativa
        percentual_atual = min(1.0, percentual_atual + 0.1)  # Aumenta 10%
        tentativas += 1
    
    # Estat√≠sticas finais
    estatisticas_finais = {
        'total_colaboradores': len(df_resultado_final),
        'colaboradores_com_ferias': (df_resultado_final['DataInicioFerias'].notna()).sum(),
        'colaboradores_ignorados': len(df_resultado_final[df_resultado_final['DataInicioFerias'].isna()]),
        'unidades_processadas': len(df_resultado_final["Unidade"].dropna().unique()),
        'tentativas_realizadas': tentativas,
        'percentual_final_usado': percentual_atual
    }
    
    return df_resultado_final, colaboradores_ignorados, estatisticas_finais

def processar_distribuicao_com_cargo(df, celulas_sel, unidades_sel, dias, percentual, data_inicial):
    """Fun√ß√£o principal para processar a distribui√ß√£o de f√©rias considerando cargo"""
    
    # Filtrar dados conforme sele√ß√£o
    df_filtrado = df[
        df["CelulaCentral"].isin(celulas_sel) &
        df["Unidade"].isin(unidades_sel)
    ].copy()
    
    # Adicionar classifica√ß√£o hier√°rquica
    if 'Cargo' in df_filtrado.columns:
        df_filtrado['NivelHierarquico'] = df_filtrado['Cargo'].apply(classificar_hierarquia_cargo)
        # Ordenar por: Unidade > N√≠vel Hier√°rquico > Data Limite
        df_filtrado = df_filtrado.sort_values(by=["Unidade", "NivelHierarquico", "DataLimite"], na_position='last')
    else:
        df_filtrado = df_filtrado.sort_values(by=["Unidade", "DataLimite"], na_position='last')
    
    # Calcular janela temporal
    datas_validas = df_filtrado["DataLimite"].dropna()
    if len(datas_validas) == 0:
        return df_filtrado, [], {'erro': 'Nenhuma data limite v√°lida encontrada'}
    
    data_min = datas_validas.min().date()
    data_max = datas_validas.max().date()
    dias_janela = (data_max - data_min).days
    meses_janela = max(1, dias_janela / 31)
    
    # Inicializar colunas de resultado
    df_filtrado["DataInicioFerias"] = pd.NaT
    df_filtrado["DataFimFerias"] = pd.NaT
    df_filtrado["Lote"] = None
    
    lote = 1
    colaboradores_ignorados = []
    colaboradores_processados = 0
    
    # Processar cada unidade separadamente
    for unidade in sorted(df_filtrado["Unidade"].dropna().unique()):
        df_unidade = df_filtrado[df_filtrado["Unidade"] == unidade]
        data_disp = data_inicial
        
        # Se tiver coluna Cargo, processar por cargo dentro da unidade
        if 'Cargo' in df_filtrado.columns:
            # Processar por n√≠vel hier√°rquico (gestores primeiro)
            for nivel in sorted(df_unidade['NivelHierarquico'].dropna().unique()):
                df_nivel = df_unidade[df_unidade['NivelHierarquico'] == nivel]
                
                for cargo in sorted(df_nivel['Cargo'].dropna().unique()):
                    grupo_idx = df_nivel[df_nivel['Cargo'] == cargo].index
                    qtd_cargo = len(grupo_idx)
                    
                    if qtd_cargo == 0:
                        continue
                    
                    # Calcular limite espec√≠fico para este cargo
                    limite_cargo = calcular_limite_por_cargo(df_unidade, cargo, percentual)
                    
                    # Distribuir colaboradores do cargo em lotes
                    for i in range(0, qtd_cargo, limite_cargo):
                        idx_lote = grupo_idx[i:i+limite_cargo]
                        ini = proximo_dia_util(data_disp)
                        fim_lote = None
                        
                        for idx in idx_lote:
                            row = df_filtrado.loc[idx]
                            
                            # Verificar data limite
                            if pd.isna(row["DataLimite"]):
                                colaboradores_ignorados.append({
                                    'Nome': row.get('Nome', '[sem nome]'),
                                    'CentroCusto': row.get('CentroCustoCompleto', '[n√£o informado]'),
                                    'Unidade': unidade,
                                    'Cargo': row.get('Cargo', '[n√£o informado]'),
                                    'DataLimite': 'N√£o informada',
                                    'Motivo': 'Data limite n√£o informada'
                                })
                                continue
                            elif ini > row["DataLimite"].date():
                                colaboradores_ignorados.append({
                                    'Nome': row.get('Nome', '[sem nome]'),
                                    'CentroCusto': row.get('CentroCustoCompleto', '[n√£o informado]'),
                                    'Unidade': unidade,
                                    'Cargo': row.get('Cargo', '[n√£o informado]'),
                                    'DataLimite': row["DataLimite"].strftime('%d/%m/%Y'),
                                    'Motivo': 'Data limite anterior ao per√≠odo calculado'
                                })
                                continue
                            
                            # Calcular per√≠odo de f√©rias
                            fim = gerar_data_fim(ini, dias)
                            df_filtrado.at[idx, "DataInicioFerias"] = pd.Timestamp(ini)
                            df_filtrado.at[idx, "DataFimFerias"] = pd.Timestamp(fim)
                            df_filtrado.at[idx, "Lote"] = lote
                            colaboradores_processados += 1
                            
                            if fim_lote is None or fim > fim_lote:
                                fim_lote = fim
                        
                        # Avan√ßar data para pr√≥ximo lote
                        if fim_lote:
                            # Intervalo maior para cargos de gest√£o
                            intervalo_dias = 7 if nivel <= 2 else 1
                            data_disp = proximo_dia_util(fim_lote + timedelta(days=intervalo_dias))
                            lote += 1
        
        else:
            # Processamento sem considerar cargo (compatibilidade)
            grupo_idx = df_unidade.index
            qtd_unidade = len(grupo_idx)
            
            if qtd_unidade > 0:
                tam_lote = max(1, int(qtd_unidade * percentual))
                
                for i in range(0, qtd_unidade, tam_lote):
                    idx_lote = grupo_idx[i:i+tam_lote]
                    ini = proximo_dia_util(data_disp)
                    fim_lote = None
                    
                    for idx in idx_lote:
                        row = df_filtrado.loc[idx]
                        
                        if pd.isna(row["DataLimite"]) or ini > row["DataLimite"].date():
                            colaboradores_ignorados.append({
                                'Nome': row.get('Nome', '[sem nome]'),
                                'CentroCusto': row.get('CentroCustoCompleto', '[n√£o informado]'),
                                'Unidade': unidade,
                                'Cargo': 'N/A',
                                'DataLimite': row["DataLimite"].strftime('%d/%m/%Y') if pd.notna(row["DataLimite"]) else 'N√£o informada',
                                'Motivo': 'Data limite incompat√≠vel' if pd.notna(row["DataLimite"]) else 'Data limite n√£o informada'
                            })
                            continue
                        
                        fim = gerar_data_fim(ini, dias)
                        df_filtrado.at[idx, "DataInicioFerias"] = pd.Timestamp(ini)
                        df_filtrado.at[idx, "DataFimFerias"] = pd.Timestamp(fim)
                        df_filtrado.at[idx, "Lote"] = lote
                        colaboradores_processados += 1
                        
                        if fim_lote is None or fim > fim_lote:
                            fim_lote = fim
                    
                    if fim_lote:
                        data_disp = proximo_dia_util(fim_lote + timedelta(days=1))
                        lote += 1
    
    return df_filtrado, colaboradores_ignorados, {
        'total_colaboradores': len(df_filtrado),
        'dias_janela': dias_janela,
        'meses_janela': meses_janela,
        'colaboradores_com_ferias': colaboradores_processados,
        'colaboradores_ignorados': len(colaboradores_ignorados),
        'unidades_processadas': len(df_filtrado["Unidade"].dropna().unique())
    }

def criar_grafico_distribuicao_mensal(df):
    """Cria gr√°fico da distribui√ß√£o mensal de f√©rias"""
    if df.empty or 'DataInicioFerias' not in df.columns:
        return None
        
    df_temp = df.copy()
    df_temp = df_temp[df_temp['DataInicioFerias'].notna()]
    
    if len(df_temp) == 0:
        return None
        
    df_temp["Mes_Ano"] = pd.to_datetime(df_temp["DataInicioFerias"], errors='coerce').dt.to_period("M")
    
    # Contar agendamentos por unidade e m√™s
    tabela_pivot = df_temp.groupby(["Unidade", "Mes_Ano"]).size().reset_index(name='Quantidade')
    tabela_pivot["Mes_Ano"] = tabela_pivot["Mes_Ano"].astype(str)
    
    if tabela_pivot.empty:
        return None
    
    # Criar gr√°fico de barras
    fig = px.bar(
        tabela_pivot, 
        x="Mes_Ano", 
        y="Quantidade", 
        color="Unidade",
        title="üìä Distribui√ß√£o de F√©rias por M√™s e Unidade",
        labels={"Mes_Ano": "M√™s/Ano", "Quantidade": "Colaboradores de F√©rias", "Unidade": "Unidade"}
    )
    
    fig.update_layout(
        xaxis_tickangle=-45,
        height=500,
        showlegend=True,
        xaxis_title="Per√≠odo (M√™s/Ano)",
        yaxis_title="Quantidade de Colaboradores",
        hovermode='x unified'
    )
    
    return fig

def grafico_real_vs_limite(df_resultado, percentual):
    """
    Gera um gr√°fico comparando colaboradores agendados (Real) x Limite permitido
    """
    if df_resultado.empty or 'DataInicioFerias' not in df_resultado.columns:
        return None
    
    # Filtrar apenas registros com f√©rias agendadas
    df_tmp = df_resultado[df_resultado['DataInicioFerias'].notna()].copy()
    
    if df_tmp.empty:
        return None
    
    df_tmp['Mes_Ano'] = pd.to_datetime(df_tmp['DataInicioFerias'], errors='coerce').dt.to_period('M')

    # Real: quantos colaboradores por unidade e m√™s
    real = df_tmp.groupby(['Unidade', 'Mes_Ano']).size().reset_index(name='Real')

    # Total de colaboradores por unidade (para o c√°lculo do limite)
    total_unidade = df_resultado.groupby('Unidade').size().reset_index(name='Total')

    # Cruzar para obter o limite te√≥rico
    real = real.merge(total_unidade, on='Unidade', how='left')
    real['Limite'] = (real['Total'] * percentual).round().astype(int)
    real['Limite'] = real['Limite'].clip(lower=1)  # M√≠nimo 1 pessoa

    # Converter per√≠odo para string
    real['Mes_Ano_Str'] = real['Mes_Ano'].astype(str)

    if real.empty:
        return None

    # Criar gr√°fico de barras para Real
    fig = px.bar(
        real,
        x='Mes_Ano_Str',
        y='Real',
        color='Unidade',
        title='üìà Real √ó Limite por Unidade e M√™s',
        labels={'Mes_Ano_Str': 'M√™s/Ano', 'Real': 'Colaboradores', 'Unidade': 'Unidade'}
    )

    # Adicionar linhas de limite para cada unidade
    cores_unidade = px.colors.qualitative.Plotly
    for i, unidade in enumerate(real['Unidade'].unique()):
        dados_unidade = real[real['Unidade'] == unidade].sort_values('Mes_Ano_Str')
        
        fig.add_scatter(
            x=dados_unidade['Mes_Ano_Str'],
            y=dados_unidade['Limite'],
            mode='lines+markers',
            name=f'Limite {unidade}',
            line=dict(color=cores_unidade[i % len(cores_unidade)], dash='dash'),
            marker=dict(symbol='diamond')
        )

    fig.update_layout(
        xaxis_title='M√™s/Ano',
        yaxis_title='Quantidade de Colaboradores',
        height=600,
        hovermode='x unified',
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
    )
    
    return fig

def criar_grafico_distribuicao_por_cargo(df):
    """Cria gr√°fico da distribui√ß√£o por cargo"""
    if df.empty or 'Cargo' not in df.columns or 'DataInicioFerias' not in df.columns:
        return None
        
    df_temp = df.copy()
    df_temp = df_temp[df_temp['DataInicioFerias'].notna()]
    
    if len(df_temp) == 0:
        return None
    
    # Adicionar classifica√ß√£o hier√°rquica
    df_temp['NivelHierarquico'] = df_temp['Cargo'].apply(classificar_hierarquia_cargo)
    nivel_descricao = {1: 'Alta Gest√£o', 2: 'Gest√£o Intermedi√°ria', 3: 'Operacional'}
    df_temp['DescricaoNivel'] = df_temp['NivelHierarquico'].map(nivel_descricao)
    
    df_temp["Mes_Ano"] = pd.to_datetime(df_temp["DataInicioFerias"], errors='coerce').dt.to_period("M")
    
    # Contar por n√≠vel hier√°rquico e m√™s
    tabela_cargo = df_temp.groupby(["DescricaoNivel", "Mes_Ano"]).size().reset_index(name='Quantidade')
    tabela_cargo["Mes_Ano"] = tabela_cargo["Mes_Ano"].astype(str)
    
    if tabela_cargo.empty:
        return None
    
    fig = px.bar(
        tabela_cargo,
        x="Mes_Ano",
        y="Quantidade", 
        color="DescricaoNivel",
        title="üëî Distribui√ß√£o de F√©rias por N√≠vel Hier√°rquico",
        labels={"Mes_Ano": "M√™s/Ano", "Quantidade": "Colaboradores de F√©rias", "DescricaoNivel": "N√≠vel Hier√°rquico"}
    )
    
    fig.update_layout(
        xaxis_tickangle=-45,
        height=500,
        showlegend=True
    )
    
    return fig

def criar_grafico_centro_custo(df):
    """Cria gr√°fico da distribui√ß√£o por centro de custo"""
    if df.empty or 'CelulaCentral' not in df.columns:
        return None
    
    # Contar por centro de custo
    centro_custo_stats = df.groupby(['CelulaCentral', 'CodigoCusto']).size().reset_index(name='Quantidade')
    centro_custo_stats['Label'] = centro_custo_stats['CodigoCusto'] + ' - ' + centro_custo_stats['CelulaCentral']
    
    if centro_custo_stats.empty:
        return None
    
    fig = px.pie(
        centro_custo_stats,
        values='Quantidade',
        names='Label',
        title="üè¢ Distribui√ß√£o de Colaboradores por Centro de Custo"
    )
    
    fig.update_layout(height=500)
    
    return fig

def criar_analise_datas_limite(df):
    """Cria an√°lise da distribui√ß√£o de datas limite por unidade"""
    if df.empty or 'DataLimite' not in df.columns:
        return None, None
    
    # Filtrar apenas registros com data limite v√°lida
    df_valido = df[df['DataLimite'].notna()].copy()
    
    if len(df_valido) == 0:
        return None, None
    
    # Criar coluna de per√≠odo (M√™s/Ano da data limite)
    df_valido['PeriodoLimite'] = pd.to_datetime(df_valido['DataLimite']).dt.to_period('M')
    
    # An√°lise por unidade e per√≠odo
    analise_detalhada = df_valido.groupby(['Unidade', 'PeriodoLimite']).size().reset_index(name='Quantidade')
    analise_detalhada['PeriodoLimite_Str'] = analise_detalhada['PeriodoLimite'].astype(str)
    
    # An√°lise resumida por unidade
    resumo_unidades = df_valido.groupby('Unidade').agg({
        'DataLimite': ['count', 'min', 'max']
    }).round(2)
    resumo_unidades.columns = ['Total_Colaboradores', 'Data_Limite_Menor', 'Data_Limite_Maior']
    resumo_unidades = resumo_unidades.reset_index()
    
    # Criar gr√°fico de distribui√ß√£o
    if not analise_detalhada.empty:
        fig = px.bar(
            analise_detalhada,
            x='PeriodoLimite_Str',
            y='Quantidade',
            color='Unidade',
            title='üìÖ Distribui√ß√£o de Datas Limite por Per√≠odo e Unidade',
            labels={
                'PeriodoLimite_Str': 'Per√≠odo (M√™s/Ano da Data Limite)',
                'Quantidade': 'N√∫mero de Colaboradores',
                'Unidade': 'Unidade/Subc√©lula'
            }
        )
        
        fig.update_layout(
            xaxis_tickangle=-45,
            height=500,
            showlegend=True,
            hovermode='x unified'
        )
        
        return fig, resumo_unidades
    
    return None, resumo_unidades

def criar_tabela_detalhada_datas_limite(df):
    """Cria tabela detalhada com estat√≠sticas por unidade"""
    if df.empty or 'DataLimite' not in df.columns:
        return None
    
    df_valido = df[df['DataLimite'].notna()].copy()
    
    if len(df_valido) == 0:
        return None
    
    # Estat√≠sticas detalhadas por unidade
    estatisticas = []
    
    for unidade in sorted(df_valido['Unidade'].unique()):
        dados_unidade = df_valido[df_valido['Unidade'] == unidade]
        
        # Calcular estat√≠sticas
        total = len(dados_unidade)
        data_min = dados_unidade['DataLimite'].min()
        data_max = dados_unidade['DataLimite'].max()
        
        # Pr√≥ximos 30, 60, 90 dias
        hoje = datetime.now().date()
        proximo_30 = len(dados_unidade[pd.to_datetime(dados_unidade['DataLimite']).dt.date <= (hoje + timedelta(days=30))])
        proximo_60 = len(dados_unidade[pd.to_datetime(dados_unidade['DataLimite']).dt.date <= (hoje + timedelta(days=60))])
        proximo_90 = len(dados_unidade[pd.to_datetime(dados_unidade['DataLimite']).dt.date <= (hoje + timedelta(days=90))])
        
        # Estat√≠sticas por cargo se dispon√≠vel
        gestores = 0
        if 'Cargo' in dados_unidade.columns:
            gestores = len(dados_unidade[dados_unidade['Cargo'].apply(classificar_hierarquia_cargo) <= 2])
        
        # Centros de custo √∫nicos na unidade
        centros_custo = dados_unidade['CodigoCusto'].nunique() if 'CodigoCusto' in dados_unidade.columns else 'N/A'
        
        estatisticas.append({
            'Unidade': unidade,
            'Total_Colaboradores': total,
            'Centros_Custo': centros_custo,
            'Gestores': gestores if 'Cargo' in dados_unidade.columns else 'N/A',
            'Data_Limite_Mais_Proxima': data_min.strftime('%d/%m/%Y'),
            'Data_Limite_Mais_Distante': data_max.strftime('%d/%m/%Y'),
            'Pr√≥ximos_30_dias': proximo_30,
            'Pr√≥ximos_60_dias': proximo_60,
            'Pr√≥ximos_90_dias': proximo_90,
            'Intervalo_Dias': (data_max.date() - data_min.date()).days
        })
    
    return pd.DataFrame(estatisticas)

def exportar_para_excel(df):
    """Exporta DataFrame para Excel e retorna o arquivo em bytes"""
    output = BytesIO()
    
    # Preparar dados para exporta√ß√£o
    df_export = df.copy()
    
    # Converter datas para formato brasileiro
    for col in ["DataLimite", "DataInicioFerias", "DataFimFerias"]:
        if col in df_export.columns:
            df_export[col] = pd.to_datetime(df_export[col], errors='coerce').dt.strftime('%d/%m/%Y')
            df_export[col] = df_export[col].replace('NaT', '')
    
    # Reordenar colunas para melhor visualiza√ß√£o
    colunas_ordem = ['Nome', 'CentroCustoCompleto', 'CodigoCusto', 'CelulaCentral', 'Unidade', 'Cargo', 'DataLimite', 'DataInicioFerias', 'DataFimFerias', 'Lote']
    colunas_disponiveis = [col for col in colunas_ordem if col in df_export.columns]
    outras_colunas = [col for col in df_export.columns if col not in colunas_ordem]
    df_export = df_export[colunas_disponiveis + outras_colunas]
    
    # Salvar no Excel
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df_export.to_excel(writer, sheet_name='Cronograma_Ferias', index=False)
    
    output.seek(0)
    return output.getvalue()

def mostrar_guia_inicial():
    """Exibe o guia inicial de uso do sistema"""
    with st.expander("üìã **GUIA DE USO R√ÅPIDO**", expanded=False):
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            **üìÅ ESTRUTURA DO ARQUIVO EXCEL:**
            - ‚úÖ M√≠nimo 14 colunas (A at√© N)
            - ‚úÖ Coluna C: Nome dos colaboradores
            - ‚úÖ Coluna F: Centro de Custo (formato: 525 - Orb Atc - Sp Alexia Dayane)
            - ‚úÖ Coluna G: Subc√©lula/Unidade  
            - ‚úÖ Coluna M: Data Limite (dd/mm/aaaa)
            - ‚úÖ Coluna N: Cargo dos colaboradores
            """)
        
        with col2:
            st.markdown("""
            **‚öôÔ∏è COMO USAR:**
            1. Carregue o arquivo Excel
            2. Configure dias e percentual
            3. Selecione centros de custo e unidades
            4. Execute o c√°lculo
            5. Analise os resultados
            6. Exporte o cronograma
            
            **üöÄ NOVO: DISTRIBUI√á√ÉO COMPLETA:**
            - Sistema agora garante 100% da planilha
            - M√∫ltiplas tentativas autom√°ticas
            - Gr√°fico Real √ó Limite
            """)

# Interface principal
def main():
    # CSS customizado para melhorar a apar√™ncia
    st.markdown("""
    <style>
    .main-header {
        text-align: center;
        color: #1f77b4;
        margin-bottom: 30px;
    }
    .metric-container {
        background-color: #f0f2f6;
        padding: 10px;
        border-radius: 10px;
        margin: 5px 0;
    }
    .success-message {
        color: #28a745;
        font-weight: bold;
    }
    .error-message {
        color: #dc3545;
        font-weight: bold;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # T√≠tulo principal
    st.markdown('<h1 class="main-header">üìÖ Agendador Inteligente de F√©rias</h1>', unsafe_allow_html=True)
    st.markdown("### *Sistema automatizado para distribui√ß√£o inteligente de f√©rias por centro de custo e cargo com garantia de 100% da planilha*")
    
    # Mostrar guia inicial
    mostrar_guia_inicial()
    
    st.markdown("---")
    
    # Sidebar para configura√ß√µes
    with st.sidebar:
        st.markdown("# ‚öôÔ∏è **CONFIGURA√á√ïES**")
        st.markdown("*Configure os par√¢metros abaixo:*")
        
        # Upload de arquivo
        st.markdown("## üìÅ **PASSO 1:** Arquivo")
        st.info("üí° Carregue o arquivo Excel com os dados dos colaboradores")
        
        arquivo = st.file_uploader(
            "Selecione o arquivo Excel:",
            type=['xlsx'],
            help="Estrutura: C=Nome, F=Centro de Custo, G=Unidade, M=Data Limite, N=Cargo"
        )
        
        if arquivo:
            try:
                with st.spinner("‚è≥ Processando arquivo com centros de custo..."):
                    df = pd.read_excel(arquivo, engine="openpyxl")
                    
                    # Validar estrutura b√°sica
                    erros = validar_estrutura_arquivo(df)
                    
                    if erros:
                        st.error("‚ùå **Problemas encontrados no arquivo:**")
                        for erro in erros:
                            st.write(erro)
                        st.warning("üí° **Solu√ß√£o:** Corrija os problemas acima e carregue o arquivo novamente.")
                        st.stop()
                    
                    # PROCESSAMENTO ESPEC√çFICO PARA CENTRO DE CUSTO
                    df['Nome'] = df.iloc[:, 2].astype(str).str.strip()  # Coluna C
                    
                    # Processar Centro de Custo (Coluna F)
                    centro_custo_raw = df.iloc[:, 5].astype(str).str.strip()
                    
                    # Aplicar processamento de centro de custo
                    processamento_cc = centro_custo_raw.apply(processar_centro_custo)
                    
                    df['CodigoCusto'] = [item[0] for item in processamento_cc]
                    df['DescricaoCusto'] = [item[1] for item in processamento_cc]
                    df['CelulaCentral'] = [item[2] for item in processamento_cc]
                    
                    # Manter refer√™ncia completa
                    df['CentroCustoCompleto'] = centro_custo_raw
                    
                    df['Unidade'] = df.iloc[:, 6].astype(str).str.strip()  # Coluna G
                    df['DataLimite'] = pd.to_datetime(df.iloc[:, 12], errors='coerce')  # Coluna M
                    
                    # Mapear coluna de cargo (Coluna N)
                    if len(df.columns) > 13:
                        df['Cargo'] = df.iloc[:, 13].astype(str).str.strip()
                    
                    # Limpar dados inv√°lidos
                    df_original_size = len(df)
                    df = df[
                        (df['Nome'] != 'nan') & 
                        (df['CelulaCentral'] != 'Outros') & 
                        (df['Unidade'] != 'nan') &
                        df['Nome'].notna() & 
                        df['CelulaCentral'].notna() & 
                        df['Unidade'].notna()
                    ]
                    
                    if len(df) == 0:
                        st.error("‚ùå Nenhum registro v√°lido encontrado ap√≥s processamento dos centros de custo")
                        st.stop()
                    
                    st.success(f"‚úÖ **{len(df)} colaboradores** processados com sucesso!")
                    if df_original_size > len(df):
                        st.warning(f"‚ö†Ô∏è {df_original_size - len(df)} registros removidos por dados inv√°lidos")
                    
                    st.info(f"üè¢ **{df['CelulaCentral'].nunique()} centros de custo** identificados")
                    
                    # Verificar se tem coluna cargo
                    tem_cargo = 'Cargo' in df.columns and not df['Cargo'].isna().all() and not (df['Cargo'] == 'nan').all()
                    
                    if tem_cargo:
                        st.info("üëî **Coluna Cargo detectada** - Distribui√ß√£o considerar√° hierarquia")
                    else:
                        st.warning("‚ö†Ô∏è **Coluna Cargo n√£o encontrada** - Distribui√ß√£o padr√£o ser√° aplicada")
                    
                    # Estat√≠sticas do arquivo
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Centros de Custo", df['CelulaCentral'].nunique())
                    with col2:
                        st.metric("Unidades/Subc√©lulas", df['Unidade'].nunique())
                    with col3:
                        if tem_cargo:
                            st.metric("Cargos √önicos", df['Cargo'].nunique())
                        else:
                            st.metric("Datas Limite", df['DataLimite'].notna().sum())
                
                st.markdown("---")
                
                # Par√¢metros de configura√ß√£o
                st.markdown("## ‚öôÔ∏è **PASSO 2:** Par√¢metros")
                st.info("üí° Configure os par√¢metros de distribui√ß√£o")
                
                dias_ferias = st.number_input(
                    "**Dias de F√©rias:**",
                    min_value=1,
                    max_value=60,
                    value=30,
                    step=1,
                    help="Quantidade de dias consecutivos de f√©rias para cada colaborador"
                )
                
                percentual = st.slider(
                    "**Percentual M√°ximo Simult√¢neo (%):**",
                    min_value=1,
                    max_value=100,
                    value=20,
                    step=1,
                    help="Percentual m√°ximo de colaboradores da mesma unidade que podem estar de f√©rias simultaneamente"
                ) / 100
                
                # Mostrar explica√ß√£o do percentual
                if tem_cargo:
                    st.caption("üí° **Com Cargo:** Gestores t√™m limites espec√≠ficos. Diretores: m√°x 1 por vez. Supervisores: m√°x 50%. Operacional: percentual configurado.")
                else:
                    st.caption(f"üí° **Sem Cargo:** Em uma equipe de 10 pessoas, no m√°ximo {max(1, int(10 * percentual))} poder√£o estar de f√©rias simultaneamente.")
                
                data_inicial = st.date_input(
                    "**Data In√≠cio da Distribui√ß√£o:**",
                    value=df['DataLimite'].dropna().min().date() if not df['DataLimite'].dropna().empty else datetime.today().date(),
                    help="Data a partir da qual as f√©rias come√ßar√£o a ser distribu√≠das"
                )
                
                st.markdown("---")
                
                # Sele√ß√£o de c√©lulas e unidades - AUTOMATICAMENTE SELECIONADAS
                st.markdown("## üéØ **PASSO 3:** Sele√ß√£o")
                st.info("üí° Por padr√£o, TODOS os centros de custo e unidades est√£o selecionados para garantir 100% da planilha")
                
                # Criar mapeamento
                mapeamento = criar_mapeamento_celula_subcelula(df)
                
                celulas_disponiveis = sorted(df['CelulaCentral'].dropna().unique())
                celulas_selecionadas = st.multiselect(
                    "**Centros de Custo:**",
                    options=celulas_disponiveis,
                    default=celulas_disponiveis,  # TODOS SELECIONADOS POR PADR√ÉO
                    help="Todos os centros de custo est√£o selecionados por padr√£o para processar a planilha completa"
                )
                
                if celulas_selecionadas:
                    # Mostrar estat√≠sticas por centro de custo
                    for celula in celulas_selecionadas[:3]:  # Mostrar apenas as 3 primeiras
                        qtd_sub = len(mapeamento.get(celula, set()))
                        codigo_exemplo = df[df['CelulaCentral'] == celula]['CodigoCusto'].iloc[0] if len(df[df['CelulaCentral'] == celula]) > 0 else 'N/A'
                        st.caption(f"üè¢ **{codigo_exemplo} - {celula}**: {qtd_sub} subc√©lulas")
                
                # Filtrar subc√©lulas baseado nas c√©lulas selecionadas
                subcelulas_disponiveis = set()
                for celula in celulas_selecionadas:
                    subcelulas_disponiveis.update(mapeamento.get(celula, set()))
                
                unidades_selecionadas = st.multiselect(
                    "**Subc√©lulas/Unidades:**",
                    options=sorted(subcelulas_disponiveis),
                    default=sorted(subcelulas_disponiveis),  # TODAS SELECIONADAS POR PADR√ÉO
                    help="Todas as unidades est√£o selecionadas por padr√£o para processar a planilha completa"
                )
                
                if unidades_selecionadas:
                    st.success(f"‚úÖ **{len(unidades_selecionadas)}** unidades selecionadas")
                
                st.markdown("---")
                
                # Bot√£o de processamento
                st.markdown("## üöÄ **PASSO 4:** Execu√ß√£o")
                st.info("üí° Execute o c√°lculo da distribui√ß√£o de f√©rias para 100% da planilha")
                
                processar = st.button(
                    "üöÄ **CALCULAR DISTRIBUI√á√ÉO COMPLETA**",
                    type="primary",
                    disabled=not (celulas_selecionadas and unidades_selecionadas),
                    help="Clique para iniciar o processamento da distribui√ß√£o de f√©rias para toda a planilha",
                    use_container_width=True
                )
                
                if not (celulas_selecionadas and unidades_selecionadas):
                    st.error("‚ö†Ô∏è Para processar toda a planilha, mantenha pelo menos um centro de custo e uma unidade selecionados")
                
            except Exception as e:
                st.error(f"‚ùå **Erro ao processar arquivo:** {str(e)}")
                st.warning("üí° Verifique se o arquivo est√° no formato correto e n√£o est√° aberto em outro programa")
                st.stop()
    
    # √Årea principal
    if arquivo and 'df' in locals():
        # Mostrar pr√©via dos dados
        st.markdown("## üë• **Pr√©via dos Dados Carregados**")
        
        # Destacar colunas importantes
        colunas_importantes = ['Nome', 'CentroCustoCompleto', 'CelulaCentral', 'Unidade', 'DataLimite']
        if 'Cargo' in df.columns:
            colunas_importantes.insert(4, 'Cargo')
        
        colunas_disponiveis = [col for col in colunas_importantes if col in df.columns]
        
        if colunas_disponiveis:
            with st.expander("üîç **Ver pr√©via dos dados**", expanded=False):
                st.dataframe(df[colunas_disponiveis].head(10), use_container_width=True)
                st.caption(f"üìä Mostrando 10 de {len(df)} registros")
        
        # An√°lise por centro de custo
        st.markdown("---")
        st.markdown("## üè¢ **An√°lise por Centro de Custo**")
        
        with st.expander("üîç **Ver distribui√ß√£o por centro de custo**", expanded=False):
            
            # Gr√°fico de pizza com centros de custo
            grafico_cc = criar_grafico_centro_custo(df)
            if grafico_cc:
                st.plotly_chart(grafico_cc, use_container_width=True)
            
            # Tabela resumo
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("### üìä **Resumo por Centro de Custo**")
                resumo_cc = df.groupby(['CodigoCusto', 'CelulaCentral']).size().reset_index(name='Total')
                resumo_cc['Label'] = resumo_cc['CodigoCusto'] + ' - ' + resumo_cc['CelulaCentral']
                for _, row in resumo_cc.head(5).iterrows():
                    st.metric(f"**{row['Label']}**", row['Total'])
            
            with col2:
                st.markdown("### üè¢ **Distribui√ß√£o por Unidade**")
                resumo_unidade = df.groupby('Unidade').size().reset_index(name='Total')
                st.dataframe(resumo_unidade.head(10), use_container_width=True)
        
        # An√°lise por cargo (se dispon√≠vel)
        if 'Cargo' in df.columns and not df['Cargo'].isna().all() and not (df['Cargo'] == 'nan').all():
            st.markdown("---")
            st.markdown("## üëî **An√°lise por Cargo e Hierarquia**")
            
            with st.expander("üîç **Ver distribui√ß√£o por cargo**", expanded=False):
                
                # Adicionar classifica√ß√£o hier√°rquica
                df['NivelHierarquico'] = df['Cargo'].apply(classificar_hierarquia_cargo)
                nivel_descricao = {1: 'Alta Gest√£o', 2: 'Gest√£o Intermedi√°ria', 3: 'Operacional'}
                df['DescricaoNivel'] = df['NivelHierarquico'].map(nivel_descricao)
                
                # Estat√≠sticas por cargo
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("### üìä **Resumo por N√≠vel Hier√°rquico**")
                    resumo_hierarquia = df.groupby('DescricaoNivel').size().reset_index(name='Total')
                    for _, row in resumo_hierarquia.iterrows():
                        st.metric(f"**{row['DescricaoNivel']}**", row['Total'])
                
                with col2:
                    st.markdown("### üè¢ **Cargos por Centro de Custo**")
                    resumo_cargo_cc = df.groupby(['CelulaCentral', 'DescricaoNivel']).size().unstack(fill_value=0)
                    st.dataframe(resumo_cargo_cc, use_container_width=True)
                
                # Alertas sobre cargos cr√≠ticos
                st.markdown("### ‚ö†Ô∏è **Alertas de Cargos Cr√≠ticos**")
                
                for centro in df['CelulaCentral'].unique():
                    df_centro = df[df['CelulaCentral'] == centro]
                    gestores = df_centro[df_centro['NivelHierarquico'] <= 2]
                    
                    if len(gestores) > 0:
                        codigo = df_centro['CodigoCusto'].iloc[0]
                        st.info(f"**{codigo} - {centro}:** {len(gestores)} cargos de gest√£o - distribui√ß√£o ser√° cuidadosa")
        
        # An√°lise de Datas Limite
        st.markdown("---")
        st.markdown("## üìÖ **An√°lise de Datas Limite por Unidade**")
        
        with st.expander("üîç **Ver an√°lise detalhada das datas limite**", expanded=False):
            
            # Filtros para an√°lise
            col1, col2 = st.columns(2)
            
            with col1:
                celulas_analise = st.multiselect(
                    "**Filtrar Centros de Custo para An√°lise:**",
                    options=sorted(df['CelulaCentral'].dropna().unique()),
                    default=sorted(df['CelulaCentral'].dropna().unique()),
                    key="analise_celulas"
                )
            
            with col2:
                unidades_analise = st.multiselect(
                    "**Filtrar Unidades para An√°lise:**",
                    options=sorted(df['Unidade'].dropna().unique()),
                    default=sorted(df['Unidade'].dropna().unique()),
                    key="analise_unidades"
                )
            
            if celulas_analise and unidades_analise:
                # Filtrar dados para an√°lise
                df_analise = df[
                    df['CelulaCentral'].isin(celulas_analise) &
                    df['Unidade'].isin(unidades_analise)
                ]
                
                if len(df_analise) > 0:
                    # Criar an√°lises
                    grafico_datas, resumo_datas = criar_analise_datas_limite(df_analise)
                    tabela_detalhada = criar_tabela_detalhada_datas_limite(df_analise)
                    
                    # Exibir resumo em m√©tricas
                    st.markdown("### üìä **Resumo Geral**")
                    
                    if resumo_datas is not None and not resumo_datas.empty:
                        col1, col2, col3, col4 = st.columns(4)
                        
                        with col1:
                            st.metric(
                                "üè¢ **Unidades Analisadas**",
                                len(resumo_datas),
                                help="N√∫mero total de unidades na an√°lise"
                            )
                        
                        with col2:
                            total_colaboradores = resumo_datas['Total_Colaboradores'].sum()
                            st.metric(
                                "üë• **Total Colaboradores**",
                                total_colaboradores,
                                help="Colaboradores com datas limite v√°lidas"
                            )
                        
                        with col3:
                            data_mais_proxima = resumo_datas['Data_Limite_Menor'].min()
                            st.metric(
                                "‚è∞ **Data Mais Pr√≥xima**",
                                data_mais_proxima.strftime('%d/%m/%Y'),
                                help="Menor data limite encontrada"
                            )
                        
                        with col4:
                            data_mais_distante = resumo_datas['Data_Limite_Maior'].max()
                            st.metric(
                                "üìÜ **Data Mais Distante**",
                                data_mais_distante.strftime('%d/%m/%Y'),
                                help="Maior data limite encontrada"
                            )
                    
                    # Gr√°fico de distribui√ß√£o
                    st.markdown("### üìà **Distribui√ß√£o por Per√≠odo**")
                    
                    if grafico_datas:
                        st.plotly_chart(grafico_datas, use_container_width=True)
                        st.caption("üí° **Interpreta√ß√£o:** Este gr√°fico mostra quando cada unidade tem colaboradores com datas limite, ajudando a identificar per√≠odos cr√≠ticos")
                    else:
                        st.warning("‚ö†Ô∏è N√£o h√° dados suficientes para gerar o gr√°fico de distribui√ß√£o")
                    
                    # Tabela detalhada por unidade
                    st.markdown("### üìã **Estat√≠sticas Detalhadas por Unidade**")
                    
                    if tabela_detalhada is not None and not tabela_detalhada.empty:
                        st.dataframe(tabela_detalhada, use_container_width=True)
                        
                        # Bot√£o para exportar an√°lise
                        st.markdown("### üíæ **Exportar An√°lise**")
                        
                        output_analise = BytesIO()
                        with pd.ExcelWriter(output_analise, engine='openpyxl') as writer:
                            tabela_detalhada.to_excel(writer, sheet_name='Analise_Datas_Limite', index=False)
                        
                        output_analise.seek(0)
                        
                        st.download_button(
                            label="üì• **BAIXAR AN√ÅLISE DE DATAS LIMITE (Excel)**",
                            data=output_analise.getvalue(),
                            file_name=f"analise_datas_limite_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx",
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        )
        
        # Processar se solicitado
        if processar and celulas_selecionadas and unidades_selecionadas:
            st.markdown("---")
            st.markdown("## ‚ö° **Processando Distribui√ß√£o Completa de F√©rias**")
            
            with st.spinner("üîÑ **Calculando distribui√ß√£o para 100% da planilha... aguarde...**"):
                df_resultado, ignorados, estatisticas = processar_distribuicao_completa(
                    df, celulas_selecionadas, unidades_selecionadas,
                    dias_ferias, percentual, data_inicial
                )
            
            if 'erro' in estatisticas:
                st.error(f"‚ùå **Erro:** {estatisticas['erro']}")
                st.stop()
            
            st.success("‚úÖ **Distribui√ß√£o completa conclu√≠da com sucesso!**")
            
            # Estat√≠sticas da simula√ß√£o
            st.markdown("---")
            st.markdown("## üìä **Estat√≠sticas da Simula√ß√£o Completa**")
            
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.metric(
                    "üë• **Total**",
                    estatisticas['total_colaboradores'],
                    help="Total de colaboradores processados"
                )
            
            with col2:
                st.metric(
                    "‚úÖ **Agendadas**",
                    estatisticas['colaboradores_com_ferias'],
                    help="Colaboradores que receberam agendamento"
                )
            
            with col3:
                st.metric(
                    "‚ö†Ô∏è **Pendentes**",
                    estatisticas['colaboradores_ignorados'],
                    help="Colaboradores que n√£o puderam ser agendados"
                )
            
            with col4:
                st.metric(
                    "üöÄ **Tentativas**",
                    estatisticas.get('tentativas_realizadas', 1),
                    help="N√∫mero de rodadas de processamento realizadas"
                )
            
            with col5:
                st.metric(
                    "üìà **% Final**",
                    f"{int(estatisticas.get('percentual_final_usado', percentual) * 100)}%",
                    help="Percentual m√°ximo utilizado na √∫ltima tentativa"
                )
            
            # Taxa de sucesso
            if estatisticas['total_colaboradores'] > 0:
                taxa_sucesso = (estatisticas['colaboradores_com_ferias'] / estatisticas['total_colaboradores']) * 100
                
                if taxa_sucesso >= 95:
                    st.success(f"üéâ **Excelente resultado!** {taxa_sucesso:.1f}% dos colaboradores foram contemplados")
                elif taxa_sucesso >= 80:
                    st.warning(f"‚ö° **Bom resultado:** {taxa_sucesso:.1f}% dos colaboradores foram contemplados")
                else:
                    st.error(f"‚ö†Ô∏è **Aten√ß√£o:** Apenas {taxa_sucesso:.1f}% dos colaboradores foram contemplados")
            
            # Gr√°ficos de distribui√ß√£o
            st.markdown("---")
            st.markdown("## üìà **Visualiza√ß√µes da Distribui√ß√£o**")
            
            # Tabs para diferentes gr√°ficos
            tab1, tab2, tab3 = st.tabs(["üìä **Por Unidade**", "üëî **Por Cargo**", "üìà **Real √ó Limite**"])
            
            with tab1:
                grafico_unidade = criar_grafico_distribuicao_mensal(df_resultado)
                if grafico_unidade:
                    st.plotly_chart(grafico_unidade, use_container_width=True)
                    st.caption("üí° Distribui√ß√£o mensal de f√©rias por unidade")
                else:
                    st.warning("‚ö†Ô∏è N√£o h√° dados suficientes para gerar o gr√°fico por unidade")
            
            with tab2:
                if 'Cargo' in df_resultado.columns:
                    grafico_cargo = criar_grafico_distribuicao_por_cargo(df_resultado)
                    if grafico_cargo:
                        st.plotly_chart(grafico_cargo, use_container_width=True)
                        st.caption("üí° Distribui√ß√£o mensal por n√≠vel hier√°rquico")
                    else:
                        st.warning("‚ö†Ô∏è N√£o h√° dados suficientes para gerar o gr√°fico por cargo")
                else:
                    st.info("‚ÑπÔ∏è Gr√°fico por cargo dispon√≠vel apenas quando coluna Cargo est√° presente")
            
            with tab3:
                # NOVO GR√ÅFICO: Real √ó Limite
                grafico_real_limite = grafico_real_vs_limite(df_resultado, percentual)
                if grafico_real_limite:
                    st.plotly_chart(grafico_real_limite, use_container_width=True)
                    st.caption("üí° **Interpreta√ß√£o:** Barras = Real agendado, Linhas tracejadas = Limite permitido por unidade")
                    
                    # An√°lise do gr√°fico
                    st.markdown("### üìã **An√°lise Real √ó Limite**")
                    
                    # Calcular estat√≠sticas de conformidade
                    df_analise_limite = df_resultado[df_resultado['DataInicioFerias'].notna()].copy()
                    df_analise_limite['Mes_Ano'] = pd.to_datetime(df_analise_limite['DataInicioFerias']).dt.to_period('M')
                    
                    real_por_unidade_mes = df_analise_limite.groupby(['Unidade', 'Mes_Ano']).size().reset_index(name='Real')
                    total_por_unidade = df_resultado.groupby('Unidade').size().reset_index(name='Total')
                    analise_limite = real_por_unidade_mes.merge(total_por_unidade, on='Unidade')
                    analise_limite['Limite'] = (analise_limite['Total'] * percentual).round().astype(int).clip(lower=1)
                    analise_limite['Status'] = analise_limite.apply(lambda x: 'Dentro do Limite' if x['Real'] <= x['Limite'] else 'Acima do Limite', axis=1)
                    
                    status_counts = analise_limite['Status'].value_counts()
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("‚úÖ **Dentro do Limite**", status_counts.get('Dentro do Limite', 0))
                    with col2:
                        st.metric("‚ö†Ô∏è **Acima do Limite**", status_counts.get('Acima do Limite', 0))
                    
                    if status_counts.get('Acima do Limite', 0) > 0:
                        st.warning("‚ö†Ô∏è Algumas unidades/per√≠odos excederam o limite configurado. Considere ajustar os par√¢metros.")
                else:
                    st.warning("‚ö†Ô∏è N√£o h√° dados suficientes para gerar o gr√°fico Real √ó Limite")
            
            # Cronograma detalhado
            st.markdown("---")
            st.markdown("## üìÖ **Cronograma de F√©rias**")
            
            # Filtros para visualiza√ß√£o
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                filtro_unidades = st.multiselect(
                    "**Filtrar Unidades:**",
                    options=sorted(df_resultado['Unidade'].dropna().unique()),
                    default=sorted(df_resultado['Unidade'].dropna().unique())[:5],  # Primeiras 5 por padr√£o
                    key="filtro_cronograma_unidades"
                )
            
            with col2:
                mostrar_apenas_agendados = st.checkbox(
                    "**Apenas com f√©rias agendadas**",
                    value=True
                )
            
            with col3:
                if 'Cargo' in df_resultado.columns:
                    filtro_cargo = st.multiselect(
                        "**Filtrar por N√≠vel:**",
                        options=['Alta Gest√£o', 'Gest√£o Intermedi√°ria', 'Operacional'],
                        default=['Alta Gest√£o', 'Gest√£o Intermedi√°ria', 'Operacional']
                    )
                else:
                    filtro_cargo = []
            
            with col4:
                ordenar_por = st.selectbox(
                    "**Ordenar por:**",
                    options=['Unidade', 'DataInicioFerias', 'DataLimite', 'Nome', 'CelulaCentral'] + (['Cargo'] if 'Cargo' in df_resultado.columns else []),
                    index=1  # DataInicioFerias por padr√£o
                )
            
            # Aplicar filtros
            df_cronograma = df_resultado[df_resultado['Unidade'].isin(filtro_unidades)] if filtro_unidades else df_resultado
            
            if mostrar_apenas_agendados:
                df_cronograma = df_cronograma[df_cronograma['DataInicioFerias'].notna()]
            
            # Filtrar por cargo se dispon√≠vel
            if 'Cargo' in df_cronograma.columns and filtro_cargo:
                df_cronograma = df_cronograma.copy()
                nivel_descricao = {1: 'Alta Gest√£o', 2: 'Gest√£o Intermedi√°ria', 3: 'Operacional'}
                df_cronograma['DescricaoNivel'] = df_cronograma['Cargo'].apply(
                    lambda x: nivel_descricao.get(classificar_hierarquia_cargo(x), 'Operacional')
                )
                df_cronograma = df_cronograma[df_cronograma['DescricaoNivel'].isin(filtro_cargo)]
            
            # Ordenar
            df_cronograma = df_cronograma.sort_values(by=ordenar_por, na_position='last')
            
            # Preparar para exibi√ß√£o
            colunas_exibir = ['Nome', 'CentroCustoCompleto', 'CelulaCentral', 'Unidade']
            if 'Cargo' in df_cronograma.columns:
                colunas_exibir.append('Cargo')
            colunas_exibir.extend(['DataLimite', 'DataInicioFerias', 'DataFimFerias', 'Lote'])
            
            df_display = df_cronograma[colunas_exibir].copy()
            
            # Formatar datas
            for col in ['DataLimite', 'DataInicioFerias', 'DataFimFerias']:
                if col in df_display.columns:
                    df_display[col] = pd.to_datetime(df_display[col], errors='coerce').dt.strftime('%d/%m/%Y')
                    df_display[col] = df_display[col].replace('NaT', '-')
            
            # Exibir cronograma
            if len(df_display) > 0:
                st.dataframe(df_display, use_container_width=True, height=400)
                st.caption(f"üìä **Exibindo {len(df_display)}** de {len(df_resultado)} registros")
            else:
                st.info("‚ÑπÔ∏è Nenhum registro encontrado com os filtros aplicados")
            
            # Relat√≥rio de exce√ß√µes
            if ignorados:
                st.markdown("---")
                st.markdown("## ‚ö†Ô∏è **Relat√≥rio de Exce√ß√µes**")
                
                df_ignorados = pd.DataFrame(ignorados)
                st.dataframe(df_ignorados, use_container_width=True)
                
                # An√°lise dos motivos
                motivos = df_ignorados['Motivo'].value_counts()
                st.markdown("**üìà Principais motivos:**")
                for motivo, qtd in motivos.items():
                    st.write(f"- **{motivo}:** {qtd} colaboradores")
                
                st.info("üí° **Dica:** Ajuste as datas limite na planilha original ou altere a data de in√≠cio da distribui√ß√£o")
            
            # Colaboradores sem agendamento
            pendentes_finais = df_resultado[df_resultado['DataInicioFerias'].isna()]
            if not pendentes_finais.empty:
                st.markdown("---")
                st.markdown("## üîç **Colaboradores Sem Agendamento**")
                st.warning(f"‚ö†Ô∏è {len(pendentes_finais)} colaboradores n√£o puderam ser agendados mesmo ap√≥s m√∫ltiplas tentativas")
                
                # Mostrar os pendentes
                colunas_pendentes = ['Nome', 'CentroCustoCompleto', 'CelulaCentral', 'Unidade', 'DataLimite']
                if 'Cargo' in pendentes_finais.columns:
                    colunas_pendentes.insert(-1, 'Cargo')
                
                df_pendentes_display = pendentes_finais[colunas_pendentes].copy()
                df_pendentes_display['DataLimite'] = pd.to_datetime(df_pendentes_display['DataLimite'], errors='coerce').dt.strftime('%d/%m/%Y')
                df_pendentes_display['DataLimite'] = df_pendentes_display['DataLimite'].replace('NaT', 'N√£o informada')
                
                st.dataframe(df_pendentes_display, use_container_width=True)
                
                st.info("""
                üí° **Recomenda√ß√µes para resolver:**
                - Verifique se as datas limite est√£o corretas
                - Considere estender o per√≠odo de distribui√ß√£o
                - Aumente o percentual m√°ximo permitido
                - Revise as regras de cargo se aplic√°vel
                """)
            
            # Exporta√ß√£o
            st.markdown("---")
            st.markdown("## üíæ **Exportar Resultados**")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                excel_data = exportar_para_excel(df_resultado)
                st.download_button(
                    label="üì• **BAIXAR CRONOGRAMA COMPLETO (Excel)**",
                    data=excel_data,
                    file_name=f"cronograma_ferias_completo_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
            
            with col2:
                st.metric("üìÑ **Total Registros**", len(df_resultado))
            
            with col3:
                if not pendentes_finais.empty:
                    # Exportar apenas pendentes
                    excel_pendentes = exportar_para_excel(pendentes_finais)
                    st.download_button(
                        label="‚ö†Ô∏è **BAIXAR APENAS PENDENTES (Excel)**",
                        data=excel_pendentes,
                        file_name=f"colaboradores_pendentes_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    )
            
            st.markdown("---")
            st.success(f"üéâ **Processo conclu√≠do!** {taxa_sucesso:.1f}% da planilha foi processada com sucesso. Voc√™ pode ajustar os par√¢metros e executar novamente se necess√°rio.")
            
    else:
        # Instru√ß√µes quando n√£o h√° arquivo
        st.markdown("## üöÄ **Como Come√ßar**")
        st.info("üëà **Para come√ßar:** Carregue um arquivo Excel na barra lateral seguindo o **PASSO 1**")
        
        # Exemplo de estrutura
        st.markdown("### üìã **Exemplo de Estrutura do Arquivo Excel**")
        
        exemplo_df = pd.DataFrame({
            'A': ['Dado1', 'Dado2', 'Dado3'],
            'B': ['Info1', 'Info2', 'Info3'], 
            'C (Nome)': ['Jo√£o Silva', 'Maria Santos', 'Carlos Lima'],
            'D-E': ['...', '...', '...'],
            'F (Centro de Custo)': ['525 - Orb Atc - Sp Alexia Dayane', '330 - Orb Atc - Operacoes Sp', '1037 - Orb Atc - Rh Necxt'],
            'G (Unidade)': ['Unidade A', 'Unidade B', 'Unidade C'],
            'H-L': ['...', '...', '...'],
            'M (Data Limite)': ['31/12/2025', '30/06/2026', '15/03/2026'],
            'N (Cargo)': ['Gerente', 'Analista', 'Supervisor']
        })
        
        st.dataframe(exemplo_df, use_container_width=True)
        st.caption("üí° **Estrutura espec√≠fica:** C=Nome, F=Centro de Custo (formato completo), G=Unidade, M=Data Limite, N=Cargo")
        
        # Benef√≠cios do sistema
        st.markdown("### ‚ú® **Principais Funcionalidades**")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.markdown("""
            **üè¢ Centro de Custo Inteligente:**
            - Processa c√≥digos completos automaticamente
            - Extrai categoria principal para agrupamento
            - Mant√©m rastreabilidade completa
            - An√°lises visuais por centro de custo
            """)
        
        with col2:
            st.markdown("""
            **üëî Distribui√ß√£o por Cargo:**
            - Evita aus√™ncia simult√¢nea de gestores
            - Intervalos maiores entre cargos cr√≠ticos
            - Alertas autom√°ticos para situa√ß√µes especiais
            - Relat√≥rios hier√°rquicos detalhados
            """)
        
        with col3:
            st.markdown("""
            **üöÄ Distribui√ß√£o Completa:**
            - Garante processamento de 100% da planilha
            - M√∫ltiplas tentativas autom√°ticas
            - Gr√°fico Real √ó Limite
            - Relat√≥rio de conformidade
            """)

if __name__ == "__main__":
    main()
